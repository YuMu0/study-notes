## 计算机网络

#### TCP与UDP

**TCP的特点：**

* TCP是**面向连接**的
* 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点**一对一**的
* TCP提供**可靠交付**的服务。通过TCP连接传送的数据，无差错、不丢失、不重复，并且按序列到达
* TCP提供**全双工通信**。TCP允许通信双方的应用进程在任何时候都能**同时发送和接收**数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据
* 面向字节流。

**UDP的特点：**

* UDP是**无连接**的
* UDP使用尽最大努力交付，即**不保证可靠交付**，因此主机不需要维持复杂的链接状态
* UDP**没有拥塞控制**。因此网络出现拥塞不会使源主机的发送速率降低（对**实时应用**很有用，例如直播、视频会议等）
* UDP支持**一对一、一对多、多对一和多对多**的交互通信
* UDP的**首部开销较小**，只有8个字节，比TCP的20个字节的首部要短
* UDP是面向报文的

**TCP与UDP的区别：**

* TCP提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。TCP的可靠性体现在TCP在传输数据之前，会有**三次握手来建立连接**，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会**断开连接**来节约系统资源。这难以避免增加了许多开销，如确认、流量控制、计时器以及连接管理等。这不仅使得协议**首部增大很多**，还要**占用许多处理资源**
* UDP在传送数据之前不需要先建立连接。远地主机在收到UDP报文后，**不需要给出任何确认**。虽然UDP不提供可靠交付，但在某些情况下UDP却是一种有效的工作方式，一般用于**即时通信**，如QQ语音、QQ视频、直播等

#### TCP三次握手

![img](D:\文件\markdown笔记\计算机网络.assets\v2-1c5da3391ad30aa7aa30f9362407a77f_b.jpg)

注：TCP各头部标志位含义

* ACK：表示确认号是否有效，含ACK标志的TCP报文段为“确认报文段”
* SYN：表示请求建立一个连接，含SYN标志的TCP报文段为“同步报文段”
* FIN：表示通知对方本端要关闭连接了，含FIN标志的TCP报文段为“结束报文段”

最初客户端和服务端都处于`CLOSED(关闭)`状态，假设A(Client)主动打开连接，B(Server)被动打开连接

一开始，B的TCP服务器进程首先创建传输控制板块TCB，准备接收客户端进程的连接请求。然后服务端进程就处于`LISTEN(监听)`状态，等待客户端的连接请求

**SYN(Sequence Number)**：这个号要作为数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输问题而乱序（TCP会用这个序号来拼接数据）

* **第一次握手**：A的TCP客户端进程也是首先创建传输控制模块TCB。然后，在打算建立TCP连接时，向B发出连接请求报文段，这时首部中的同步位`SYN=1`，同时选择一个初始序号`seq=x`。TCP规定，SYN报文段不能携带数据，但要消耗一个序列号。这使，TCP客户进程进入`SYN-SENT(同步已发送)`状态
* **第二次握手**：B收到连接请求报文后，如果同意建立连接，则向A发送确认。在确认报文中把`SYN和ACK都置为1`，确认号是`ack=x+1`，同时也为自己选择一个初始序号`seq=y`。这个报文段也不能携带数据，但同时要消耗一个序号。这时TCP服务端进程进入`SYN-RCVD(同步收到)`状态
* **第三次握手**：TCP客户进程收到B的确认后，还要向B给出确认。确认报文段的`ACK置为1`，确认号`ack=y+1`，而自己的序列号`seq=x+1`。这时，TCP连接已经建立，A进入`ESTABLISHED(已建立连接)`状态

**为什么两次握手不可以？**

主要是要初始化`Sequence Number`的初始值。通信双方要互相通知对方自己SYN的初始值

此外，为了防止已经失效的连接请求报文突然又传送到了B，因而产生错误。例如，A发出的第一个连接请求报文段并没有丢失，而是在网路节点长时间滞留了，以致于延误到连接释放以后的某个时间段才到达B，这本是一个**早已失效的报文段**。但B收到后，就会误以为A发出了一次新的连接请求，同意建立连接。如果没有第三次握手，B就会一直在等待A发来数据，导致B的许多资源浪费了

**为什么不需要四次握手？**

**完全可靠的通信协议是不存在的**。没有必要再增加次数

#### TCP四次挥手

![img](D:\文件\markdown笔记\计算机网络.assets\v2-dc0bdc69237df055ff8c2aa477887237_b-1584178444045.jpg)

传输结束后，通信的双方都可以释放连接。现在A和B都处于`ESTABLISHED`状态

* **第一次挥手**：A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。A把连接释放报文段首部的终止控制位`FIN置1`，其序号`seq=u`（等于前面已传送过的数据的最后一个字节的序号加1）。这时，A进入`FIN-WAIT-1(终止等待1)`状态，等待B的确认。注意，FIN报文段即使不携带数据，也将消耗一个序号
* **第二次挥手**：B收到连接释放报文段后立即发出确认，确认号是`ack=u+1`，而这个报文段自己的序号是`seq=v`（等于B前面已经传送过的数据的最后一个字节的序号加1）。然后，B进入`CLOSED-WAIT(关闭等待)`状态。TCP服务端进程这时应该通知高层应用进程，因而从A到B方向上的连接就释放了，这时TCP连接处于**半关闭(half-close)**状态，即A已经没有数据要发送了，但B若发送数据，A仍要接收。也就是说，从B到A方向的连接并未关闭，这个状态可能持续一段时间。A收到来自B的确认后，进入`FIN-WAIT-2(终止等待2)`状态，等待B发出的连接释放报文段
* **第三次挥手**：若B已经没有要向A发送的数据，其应用进程就通知TCP释放连接。这时B发出的连接释放报文段必须使`FIN=1`。假定B的序号为w（在半关闭状态，B可能又发送了一些数据），B还必须重复上次发送过的确认好`ack=u+1`，这时B就进入`LAST-ACK(最后确认)`状态，等待A的确认
* **第四次挥手**：A在收到B的连接释放报文后，必须对此发出确认。在报文段中把ACK置1，确认号`ack=w+1`，自己的序列号为`seq=u+1`（第一次挥手发送的FIN消耗一个序号）。然后进入`TIME-WAIT(时间等待)`状态。注意，现在的TCP连接还没有释放掉，必须等待计时器设置的时间2MSL(MSL：最长报文段寿命)后，A才能进入到CLOSED状态，然后撤销传输控制块TCB，结束此次TCP连接。所以，**B结束TCP连接的状态要早于A**

**为什么TIME-WAIT状态必须等待2MSL的时间？**

* 为了保证A发送的最后一个ACK报文段能到达B。这个ACK报文段**可能丢失**，因而处于LAST-ACK状态的B收不到对FIN+ACK报文段的确认，B会**超时重传**，而A就能在2MSL时间内收到这个重传的FIN-ACK报文段，接着A重传一次确认，重新启动2MSL计时器
* 防止已失效的连接请求报文段出现在本连接中。A发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都在网络中消失，使得下一个连接中不会出现这种旧的连接请求报文段

**为什么第二次和第三次不能合并？**

服务器执行第二次挥手后，证明客户端不会再向服务端发送数据，但服务端可能还正在给客户端发送数据（可能客户端上一次请求的资源还没有发送完毕），所以此时服务端会等待把之前未传输完成的数据传输完毕之后再发送关闭请求

#### TCP协议是如何保证可靠传输的

* 数据包检验：检测数据在传输过程中的任何变化，若检验出数据包有错，则丢弃报文段并且不给出响应，这时TCP发送数据段会超时重发
* 对失序数据包重排列：TCP对失序数据进行重新排序后，才交给应用层
* 丢失重复数据：对于重复数据，能够丢弃
* 应答机制：TCP收到自TCP连接另一端的数据时，它将发送一个确认。不是立即发送，通常推迟几分之一秒
* 超时重发：当TCP发出一个段后，它启动一个定时器，等待对方确认后收到这个报文段并发回确认。如果不能及时收到确认，将重发这个报文段
* 流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能容纳的数据，这可以防止快主机致使慢主机的缓冲区溢出。TCP使用的流量控制协议是可变大小的滑动窗口协议

#### TCP拥塞控制

**拥塞控制和流量控制不同**

* 拥塞控制是一个**全局性**的过程，而流量控制指点对点的通信量的控制。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏，这种情况就叫拥塞

* 拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不至于过载。拥塞控制涉及到所有的主机、所有的路由器以及与降低网络传输性能有关的所有因素。而流量控制要做到的就是**抑制发送端到端数据的速率**，以使接收端来得及接收

为了进行拥塞控制，TCP发送方要维持一个拥塞窗口`cwnd`的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接收窗口中较小的一个

TCP的拥塞控制采用了四种算法：

* **慢开始**：思路是当主机开始发送数据时，因为还不知道网络的情况，如果立即把大量数据字节注入到网络，很可能会引起网络堵塞。一般是先探测一下，即有小到大逐渐增大发送窗口，`cwnd`初值为1，每经过一个传播轮次，加倍
* **拥塞避免**：当`cwnd`指数增长到慢开始门限`ssthresh`时，开始缓慢增大，每次增加1

当网络发生拥塞时，`ssthresh /= 2`，`cwnd`=1

* **快重传**：快重传是指接收方在收到一个失序的报文段后，就立即发出重复确认，而不需要等到自己发送数据时捎带确认。算法规定，发送方只要一连收到3个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期
* **快恢复**：发送方连续收到3个重复确认时，执行“乘法减小”算法，即`ssthresh /= 2`。考虑到如果网络拥塞的话不会连续收到几个重复确认，所以发送方认为现在网络可能没有出现拥塞，故并不执行慢开始，而是执行`cwnd = ssthresh`，然后开始拥塞避免算法，每次增加1