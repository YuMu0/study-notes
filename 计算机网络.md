#### ISO七层网络模型

![img](计算机网络.assets\v2-854e3df8ea850c977c30cb1deb1f64db_720w.jpg)



#### TCP/IP协议

![img](计算机网络.assets\v2-b336a50e1d671a5ef82f532c492474fe_720w.jpg)

**TCP包头部**

1. 16位端口号(port number)

2. 32位序号(sequence number)：用来解决包**乱序问题**

3. 32位确认号(acknowledgement number)：用来解决**丢包问题**

4. 4位头部长度(header length)：标识该TCP头部有多少个32bit(4Byte)，因为4位最多能表示15，所以TCP头部最长是60Byte

5. 6位标志位

   (1) URG，表示紧急指针是否有效

   (2) ACK，表示确认号是否有效，携带此标志的TCP报文段为“确认报文段”

   (3) PSH，提示接收端应用程序应该立即从TCP接收缓冲区中读走数据，为接收后续数据腾出空间

   (4) RST，表示要求对方重新建立连接，携带此标志的TCP报文段为“复位报文段”

   (5) SYN，表示请求建立一个连接，携带此标志的TCP报文段为"同步报文段"

   (6) FIN，表示通知对方本端要关闭连接了，携带此标志的TCP报文段为“结束报文段”

6. 16位窗口大小(window size)：TCP**流量控制**的手段。它告知对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度
7. 16位校验和(checksum)：TCP**可靠传输**的一个重要保障。由发送端填充，接收端通过算法来检验TCP报文段在传输过程中是否损坏
8. 16位紧急指针(urgent pointer)

**注意：**

> TCP的包是没有IP地址的，只有端口号

#### TCP与UDP

**TCP的特点：**

* TCP是**面向连接**的
* 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点**一对一**的
* TCP提供**可靠交付**的服务。通过TCP连接传送的数据，无差错、不丢失、不重复，并且按序列到达
* TCP提供**全双工通信**。TCP允许通信双方的应用进程在任何时候都能**同时发送和接收**数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据
* 面向字节流。

**UDP的特点：**

* UDP是**无连接**的
* UDP使用尽最大努力交付，即**不保证可靠交付**，因此主机不需要维持复杂的链接状态
* UDP**没有拥塞控制**。因此网络出现拥塞不会使源主机的发送速率降低（对**实时应用**很有用，例如直播、视频会议等）
* UDP支持**一对一、一对多、多对一和多对多**的交互通信
* UDP的**首部开销较小**，只有8个字节，比TCP的20个字节的首部要短
* UDP是面向报文的

**TCP与UDP的区别：**

* TCP提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。TCP的可靠性体现在TCP在传输数据之前，会有**三次握手来建立连接**，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会**断开连接**来节约系统资源。这难以避免增加了许多开销，如确认、流量控制、计时器以及连接管理等。这不仅使得协议**首部增大很多**，还要**占用许多处理资源**
* UDP在传送数据之前不需要先建立连接。远地主机在收到UDP报文后，**不需要给出任何确认**。虽然UDP不提供可靠交付，但在某些情况下UDP却是一种有效的工作方式，一般用于**即时通信**，如QQ语音、QQ视频、直播等

#### TCP三次握手

![img](计算机网络.assets\v2-1c5da3391ad30aa7aa30f9362407a77f_b.jpg)

注：TCP各头部标志位含义

* ACK：表示确认号是否有效，含ACK标志的TCP报文段为“确认报文段”
* SYN：表示请求建立一个连接，含SYN标志的TCP报文段为“同步报文段”
* FIN：表示通知对方本端要关闭连接了，含FIN标志的TCP报文段为“结束报文段”

最初客户端和服务端都处于`CLOSED(关闭)`状态，假设A(Client)主动打开连接，B(Server)被动打开连接

一开始，B的TCP服务器进程首先创建传输控制板块TCB，准备接收客户端进程的连接请求。然后服务端进程就处于`LISTEN(监听)`状态，等待客户端的连接请求

**SYN(Sequence Number)**：这个号要作为数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输问题而乱序（TCP会用这个序号来拼接数据）

* **第一次握手**：A的TCP客户端进程也是首先创建传输控制模块TCB。然后，在打算建立TCP连接时，向B发出连接请求报文段，这时首部中的同步位`SYN=1`，同时选择一个初始序号`seq=x`。TCP规定，SYN报文段不能携带数据，但要消耗一个序列号。这使，TCP客户进程进入`SYN-SENT(同步已发送)`状态
* **第二次握手**：B收到连接请求报文后，如果同意建立连接，则向A发送确认。在确认报文中把`SYN和ACK都置为1`，确认号是`ack=x+1`，同时也为自己选择一个初始序号`seq=y`。这个报文段也不能携带数据，但同时要消耗一个序号。这时TCP服务端进程进入`SYN-RCVD(同步收到)`状态
* **第三次握手**：TCP客户进程收到B的确认后，还要向B给出确认。确认报文段的`ACK置为1`，确认号`ack=y+1`，而自己的序列号`seq=x+1`。这时，TCP连接已经建立，A进入`ESTABLISHED(已建立连接)`状态

**为什么两次握手不可以？**

主要是要初始化`Sequence Number`的初始值。通信双方要互相通知对方自己SYN的初始值

此外，为了防止已经失效的连接请求报文突然又传送到了B，因而产生错误。例如，A发出的第一个连接请求报文段并没有丢失，而是在网路节点长时间滞留了，以致于延误到连接释放以后的某个时间段才到达B，这本是一个**早已失效的报文段**。但B收到后，就会误以为A发出了一次新的连接请求，同意建立连接。如果没有第三次握手，B就会一直在等待A发来数据，导致B的许多资源浪费了

**为什么不需要四次握手？**

**完全可靠的通信协议是不存在的**。没有必要再增加次数

#### TCP四次挥手

![img](计算机网络.assets\v2-dc0bdc69237df055ff8c2aa477887237_b-1584178444045.jpg)

传输结束后，通信的双方都可以释放连接。现在A和B都处于`ESTABLISHED`状态

* **第一次挥手**：A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。A把连接释放报文段首部的终止控制位`FIN置1`，其序号`seq=u`（等于前面已传送过的数据的最后一个字节的序号加1）。这时，A进入`FIN-WAIT-1(终止等待1)`状态，等待B的确认。注意，FIN报文段即使不携带数据，也将消耗一个序号
* **第二次挥手**：B收到连接释放报文段后立即发出确认，确认号是`ack=u+1`，而这个报文段自己的序号是`seq=v`（等于B前面已经传送过的数据的最后一个字节的序号加1）。然后，B进入`CLOSED-WAIT(关闭等待)`状态。TCP服务端进程这时应该通知高层应用进程，因而从A到B方向上的连接就释放了，这时TCP连接处于**半关闭(half-close)**状态，即A已经没有数据要发送了，但B若发送数据，A仍要接收。也就是说，从B到A方向的连接并未关闭，这个状态可能持续一段时间。A收到来自B的确认后，进入`FIN-WAIT-2(终止等待2)`状态，等待B发出的连接释放报文段
* **第三次挥手**：若B已经没有要向A发送的数据，其应用进程就通知TCP释放连接。这时B发出的连接释放报文段必须使`FIN=1`。假定B的序号为w（在半关闭状态，B可能又发送了一些数据），B还必须重复上次发送过的确认好`ack=u+1`，这时B就进入`LAST-ACK(最后确认)`状态，等待A的确认
* **第四次挥手**：A在收到B的连接释放报文后，必须对此发出确认。在报文段中把ACK置1，确认号`ack=w+1`，自己的序列号为`seq=u+1`（第一次挥手发送的FIN消耗一个序号）。然后进入`TIME-WAIT(时间等待)`状态。注意，现在的TCP连接还没有释放掉，必须等待计时器设置的时间2MSL(MSL：最长报文段寿命)后，A才能进入到CLOSED状态，然后撤销传输控制块TCB，结束此次TCP连接。所以，**B结束TCP连接的状态要早于A**

**为什么TIME-WAIT状态必须等待2MSL的时间？**

* 为了保证A发送的最后一个ACK报文段能到达B。这个ACK报文段**可能丢失**，因而处于LAST-ACK状态的B收不到对FIN+ACK报文段的确认，B会**超时重传**，而A就能在2MSL时间内收到这个重传的FIN-ACK报文段，接着A重传一次确认，重新启动2MSL计时器
* 防止已失效的连接请求报文段出现在本连接中。A发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都在网络中消失，使得下一个连接中不会出现这种旧的连接请求报文段

**为什么第二次和第三次不能合并？**

服务器执行第二次挥手后，证明客户端不会再向服务端发送数据，但服务端可能还正在给客户端发送数据（可能客户端上一次请求的资源还没有发送完毕），所以此时服务端会等待把之前未传输完成的数据传输完毕之后再发送关闭请求

#### TCP协议是如何保证可靠传输的

* 数据包检验：检测数据在传输过程中的任何变化，若检验出数据包有错，则丢弃报文段并且不给出响应，这时TCP发送数据段会超时重发
* 对失序数据包重排列：TCP对失序数据进行重新排序后，才交给应用层
* 丢失重复数据：对于重复数据，能够丢弃
* 应答机制：TCP收到自TCP连接另一端的数据时，它将发送一个确认。不是立即发送，通常推迟几分之一秒
* 超时重发：当TCP发出一个段后，它启动一个定时器，等待对方确认后收到这个报文段并发回确认。如果不能及时收到确认，将重发这个报文段
* 流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能容纳的数据，这可以防止快主机致使慢主机的缓冲区溢出。TCP使用的流量控制协议是可变大小的滑动窗口协议

#### MTU与MSS

1. MTU(Maximum Transmission Unit)

数据链路层传输的帧大小是有限制的，不能把一个太大的包直接塞给链路层，这个限制被称为**最大传输单元MTU**，一般为1500字节

不同数据链路层的MTU也是不同的，IP协议的数据报最大为65535个字节，远远超过了MTU的值，因此需要对数据进行**分片**，这也是IP协议的主要功能之一

3. MSS(Max Segment Size)

TCP为了避免被发送方分片，它主动把数据分成小段再交给网络层，最大的分段即MSS。它相当于把MTU减去IP头和TCP头的大小，所以一个MSS恰好能装进一个MTU中

![img](D:\文件\markdown笔记\计算机网络.assets\v2-5c578bd8beb44dd6a2755ce989f9a2d5_b.jpg)



#### TCP流量控制

**糊涂窗口综合征**

1. 发送端产生原因及症状

如果发送端为**产生数据很慢**的应用程序服务，例如，一次产生一个字节。如果没有特定指令，它就产生只包括一个字节数据的报文段，结果有很多41字节的IP数据报就在传来传去

2. 解决办法

**Nagle算法**：发送端的发送缓存数据积累到可以组成一个较大报文段时，或者收到接收端的ACK时，再发送。算法简单，但是考虑到了应用程序产生数据的速率，以及网络传输数据的速率。如果应用程序比网络更快，则报文段就更大；如果应用程序比网络慢，则报文段就小

3. 接收端产生的症状

如果接受端为**消耗数据很慢**的应用程序服务，例如，一次消耗一个字节。接收端很快缓存就满了，每次消耗一个字节数据后，宣布窗口大小为一个字节，于是发送端只能发送一个字节

4. 解决办法

**Clark算法**：只要有数据到达就发送确认，但宣布窗口大小为零，直到缓存空间已经能放入具有最大长度的报文段

**延迟确认**：延迟一段时间后再发送ACK，这样当发送端的TCP发送完数据后，就停下来了，同时也减少了通信量。但缺点是，延迟确认可能会让发送端超时重传

#### TCP拥塞控制

**拥塞控制和流量控制不同**

* 拥塞控制是一个**全局性**的过程，而流量控制指点对点的通信量的控制。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏，这种情况就叫拥塞

* 拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不至于过载。拥塞控制涉及到所有的主机、所有的路由器以及与降低网络传输性能有关的所有因素。而流量控制要做到的就是**抑制发送端到端数据的速率**，以使接收端来得及接收

为了进行拥塞控制，TCP发送方要维持一个拥塞窗口`cwnd`的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接收窗口中较小的一个

TCP的拥塞控制采用了四种算法：

* **慢开始**：思路是当主机开始发送数据时，因为还不知道网络的情况，如果立即把大量数据字节注入到网络，很可能会引起网络堵塞。一般是先探测一下，即有小到大逐渐增大发送窗口，`cwnd`初值为1 MSS。每收到一个ACK后，就`cwnd += 1`。那么实际上每经过一个传播轮次(1 RTT)，`cwnd加倍`
* **拥塞避免**：当`cwnd`指数增长到慢开始门限`ssthresh`时，开始缓慢增大，每个RTT增加1

当网络发生拥塞时，`ssthresh /= 2`，`cwnd`=1

* **快重传**：快重传是指接收方在收到一个失序的报文段后，就立即发出重复确认，而不需要等到自己发送数据时捎带确认。算法规定，发送方只要一连收到3个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期
* **快恢复**：发送方连续收到3个重复确认时，执行“乘法减小”算法，即`ssthresh /= 2`。考虑到如果网络拥塞的话不会连续收到几个重复确认，所以发送方认为现在网络可能没有出现拥塞，故并不执行慢开始，而是执行`cwnd = ssthresh`，然后开始拥塞避免算法，每次增加1

#### 网络IO模型

IO有两种操作，同步IO和异步IO

* 同步IO：必须等待IO操作完成后，控制权才返回给用户进程
* 异步IO：无须等待IO操作完成，就将控制权返回给用户进程
* 同步IO：发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了
* 异步IO：调用发出之后，这个调用就直接返回了，所以没有返回结果。即调用者不会立即得到结果，而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用

阻塞和非阻塞的概念描述是用户线程调用内核IO操作的方式
阻塞和非阻塞关注的是**程序在等待调用结果时的状态**

* 阻塞：IO操作需要彻底完成后才返回到用户空间
* 非阻塞：IO操作被调用后立即给用户一个状态值，不需要等到IO操作彻底完成
* 阻塞：调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才返回
* 非阻塞：不能立即得到结果之前，该调用不会阻塞当前进程

##### 4种IO模型

1. 阻塞IO模型

2. 非阻塞IO模型
3. 多路IO复用模型
4. 异步IO模型

**阻塞IO模型**

![img](计算机网络.assets\J$IM%Z_AL9ND53]H0V]UQ.png)

IO执行的两个阶段（等待数据和拷贝数据）都被阻塞了

大部分的socket接口都是阻塞型的，即系统调用时不返回结果，并让当前线程一直处于阻塞状态，只有当该系统调用获得结果或者超时出错时才返回结果

实际上，几乎所有的IO接口（包括socket接口）都是阻塞型的

简单的改进方案：服务器端使用**多线程（或多进程）——线程池、进程池**

但面对大规模的服务请求，多线程模型也会遇到瓶颈，可以用非阻塞模型来解决

**非阻塞IO模型**

![img](计算机网络.assets\7`1BSHDSP$}S9M_RS%OKNJH.png)

在非阻塞IO中，用户进程其实需要不断主动地询问kernel数据是否准备好

服务器线程可以通过循环调用`recv()`接口，在单个线程内实现对所有连接的数据接收工作。但此模型**绝不被推荐**，因为循环调用将大幅度占用CPU使用率

**多路IO复用模型**

![image](D:\文件\markdown笔记\计算机网络.assets\3.png)

多路IO复用，有时也被成为**事件驱动IO**。它的基本原理就是有个函数（如select）会不断地查询所负责的所有socket，当某个socket有数据到达了，就通知用户进程

这个模型和阻塞IO模型其实并没有太大的不同，事实上还会更差一点，因为这里需要使用两个系统调用（`select`和`recvfrom`），而阻塞IO只调用一个

`select`的优势在于它可以同时处理**多个连接**

**异步IO模型**

![img](计算机网络.assets\2.png)

用户进程发起read操作后，立刻可以去做其他事；从内核的角度，当它收到一个异步的read请求操作后，首先会立刻返回，所以不会对进程产生任何阻塞。然后内核会等待数据准备完成，然后将数据拷贝到用户内存中，当这一切完成后，内核会给用户发一个信号，返回read操作已完成的信息

其实按照这个分类，之前的阻塞IO、非阻塞IO以及多路复用IO都属于同步IO

##### select/poll/epoll

select、poll和epoll都是**多路IO复用**的机制，都是**同步IO**

**三者对比：**

首先还是来看最常见的select()和poll()，对于网络编程来说，一般认为poll()比select()要高级一些，主要源于：

* poll()不要求开发者在计算最大文件描述符时+1的操作

* poll()在应付大数目的文件描述符的时候速度更快
* select()可以监控的文件描述符数目是固定的，相对来说也比较少（1024或2048）。如果需要监控数值较大的文件描述符，或是分布得很稀疏的较少的描述符，效率也会很低。而对于poll()函数来说，可以创建特定大小的数组来保存监控的描述符，而不受文件描述符大小的影响，而且poll()可以监控的文件数目远大于select()
* select()函数的超时参数在返回时也是未定义的，考虑到可移植性，每次在超时之后在下一次进入到select()之前都需要重新设置超时参数

select()的优点：

* select()的可移植性更好，某些UNIX()系统上不支持poll()
* select()对于超时值提供了更好的精度，而poll()精度较差

epoll()的优点：

* 支持一个进程打开大数目的socket描述符（FD）
* IO效率不随FD数目增加而线性下降。传统select/poll的一个致命弱点就是，当你拥有一个很大的socket集合，由于网络的延迟，任一时间只有一部分socket是“活跃”的，但是select/poll每次调用都会线性扫描全部的集合，导致效率线性下降。但epoll每次只会对“活跃”的socket进行操作——这是因为在内核中实现epoll是根据每个FD上面的callback函数实现的，只有“活跃”的socket才会主动去调用callback函数
* 使用`mmap`加速内核和用户空间的消息传递

#### HTTP协议

HTTP是基于传出层的TCP协议的，而HTTPS协议，则是基于同处于应用层的TSL、SSL协议之上的；HTTP默认的端口号为80，HTTPS的默认端口号为443

HTTP/1.1协议中定义了9种方法来表明Request-URI指定的资源的不同操作方式，分别是：OPTIONS/HEAD/GET/POST/PUT/DELETE/TRACE/CONNECT/PATCH

##### GET和POST

GET与POST的区别

* 最直观的即语义上的区别，GET用于获取数据，POST用于提交数据

* GET请求的数据会附在URL之后，以?分割URL和传输数据，参数之间以&相连；POST把提交的数据放置在HTTP包的包体中
* GET有长度限制，受限于URL的长度，其取决于浏览器和服务器，而POST无限制

* 表面上看，POST的安全性比GET高，但实际上如果是HTTP协议，都是明文传输，都是不安全的

GET与POST的选择

* 私密性的信息请求使用POST，查询信息和想要通过URL分享的信息使用GET

##### 返回码

返回码由3位数字组成，第一个数字定义了响应的组别，其由5种可能的取值

(1) 1xx：指示信息，表示请求已接收，继续处理

(2) 2xx：成功，表示请求已被成功接收、理解和接受

(3) 3xx：重定向，要完成请求必须进行更进一步的操作

(4) 4xx：客户端错误，请求有语法错误或请求无法实现

(5) 5xx：服务器端错误，服务器未能实现合法的请求

常见状态码及和其状态描述说明：

> 200  OK							//请求成功
>
> 400  Bad Request		   //客户端请求有语法错误，服务器端无法理解
>
> 401  Unauthorized		 //请求未经授权
>
> 403  Forbidden				//服务器拒绝提供服务
>
> 404  Not Found				//请求资源不存在，比如输入了错误的URL
>
> 500  Internal Server Error		//服务器发生不可预期的错误
>
> 503  Server Unavailable			//服务器当前不能处理客户端的请求，一段时间后可能恢复

#### 浏览器输入URL回车后发生了什么

##### 1. URL解析

**地址解析**

首先判断你输入的是一个合法的URL，还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作

**HSTS**(HTTP Strict Transport Security，一种新的Web安全协议)

如果网站采用了HSTS协议，就会强制浏览器使用HTTPS与服务器创建连接

**其他操作**

安全检查、访问限制等

**检查缓存**

如果浏览器内有相关内容的缓存，且没有过期，就直接返回缓存，不需要向服务器请求

##### 2. DNS查询

![img](D:\文件\markdown笔记\计算机网络.assets\v2-4e68ba51d411b26b607307dbd83a97ed_b.png)

依次从浏览器、操作系统、路由器、ISP查询是否有DNS缓存，如果都没有，本地DNS服务器会将请求转发到互联网的根域名服务器进行递归查询

##### 3. TCP连接

TCP/IP分为四层，每层都要对数据进行封装

![img](D:\文件\markdown笔记\计算机网络.assets\v2-6e7f3f12f414b1e970467f50c0062c6e_b.jpg)

**应用层：发送HTTP请求**

浏览器会根据IP地址构造一个HTTP报文，其中包括：

* 请求包头：请求方法、目标地址、遵循的协议等
* 请求主体

注意，浏览器只能发送GET、POST方法，而打开网页使用的是GET方法

**传输层：TCP传输报文**

传输层会发起一条到达服务器的TCP连接，为了方便传输，会对数据进行切割，并标记编号

* TCP三次握手

**网络层：IP协议和ARP协议**

IP协议是TCP/IP协议的核心，所有的TCP、UDP、IMCP、IGMP的数据都以IP数据格式传输。

注意:

>  IP协议不是可靠的协议，可靠性是TCP要做的事情

ARP是根据IP地址获取MAC地址的协议。主机要发送一个IP包的时候，先检查自己的ARP缓存，如果查询的IP-MAC值对不存在，那么主机就向网络发送一个ARP协议广播包，收到广播包的所有主机都会查询自己的IP地址，如果符合条件，就发送一个包含自己MAC地址的ARP包给发送广播的主机

注意：

> OSI参考模型中，ARP协议位于链路层，而在TCP/IP中，它位于网络层

##### 4. 服务器处理请求

服务器接受TCP报文后，会对连接进行处理，对HTTP协议进行解析，并逐一验证

##### 5. 浏览器接受响应

浏览器接收到来自服务器的响应资源后，会对资源进行分析

首先查看Response Header，根据不同的状态码做不同的事；如果资源进行了压缩，还需要解压

然后对响应资源做缓存

##### 6. 渲染页面

解析HTML得到DOM树，然后使用CSS进行渲染，最后编译执行JavaScript