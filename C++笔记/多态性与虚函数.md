## 多态性与虚函数

#### 多态性

##### 多态性概述

多态性的两种描述：

* 指具有不同功能的函数可以用一个函数名
* 指向不同的对象发送同一个消息，不同的对象在接收时会产生不同的行为

从实现的角度看，分为静态多态性和动态多态性

* 静态多态性——函数重载和运算符重载

* 运行时的多态——继承和虚函数

C++的多态性可以分为四类：

**通用多态：**

* 参数多态：例如**函数模板**和**类模板**
* 包含多态：研究类族中定义于不同类中的同名成员函数的多态行为，主要通过**虚函数**实现

**专用多态：**

* 重载多态：例如**函数重载**和**运算符重载**
* 强制多态：指将一个变元的类型加以变化，以符合一个函数或操作的要求，例如**强制类型转换**

##### 多态的实现

联编：即把函数名和函数体的程序代码连接在一起过程

* **静态联编**：在**编译**阶段完成的联编
* **动态联编**：在**运行**阶段完成的联编

多态从实现角度来讲可以划分为两类：

* **编译时的多态**（用静态联编实现）：静态联编时，系统用实参和形参进行匹配，对同名从重载函数进行参数上的区分，然后进行联编，从而实现多态
* **运行时的多态**（用动态联编实现）：当程序调用到某一个函数名时，才去寻找和连接其程序代码，对面向对象程序设计而言，就是当对象接收到某一消息时，才去寻找和连接相应的方法

一般而言，**编译型语言**都采用静态联编，而**解释型语言**都采用动态联编

纯粹的OOP语言由于其执行的是**消息传递**，所以只能采用动态联编。而为了保持C语言的高效性，C++仍然是**编译型**的。C++设计者通过**虚函数**的机制，解决了这个问题，利用虚函数机制，C++可**部分地采用动态联编**。也就是说，C++实际上是采用了**静态联编和动态联编相结合**的联编方法

对于C++：

* 编译时的多态——函数重载和运算符重载
* 运行时的多态——虚函数

#### 虚函数

##### 虚函数基础

虚函数允许函数调用与函数体之间的联系在运行时才建立，也就是运行时才决定如何动作，即动态联编

虚函数的声明：`virtual 类型说明符 函数名(参数表);`

判断派生类成员函数是否为虚函数的规则：

* 该函数必须与基类的虚函数有相同的名称
* 该函数与基类的虚函数有相同的参数个数及相同的对应参数类型
* 该函数与基类的虚函数有相同的返回类型或者满足赋值兼容规则的指针、引用类型的返回类型

虚函数的几点说明：

* 通过定义虚函数来使用C++提供的多态机制时，派生类应该从它的基类**公有派生**
* 必须首先在基类中定义虚函数
* 在派生类对基类中声明的虚函数进行重定义时，关键字`virtual`可以写也可以不写
* 使用**对象名和点运算符**的方式也可以调用虚函数，调用结果也相同，但是这样没有充分利用虚函数的特性。只有通过**基类指针或引用**访问虚函数时才能获得运行时的多态性
* 一个虚函数无论被**公有继承**多少次，仍然保持虚函数的特性
* 虚函数必须是其所在类的**成员函数**，**不能是友元函数**，也**不能是静态成员函数**，因为虚函数要靠特定的对象来决定该激活哪个函数
* **内联函数不能是虚函数**。因为内联函数不能在运行中动态确定其位置，即使虚函数在类的内部定义，编译时仍然看做**非内联**的
* **构造函数不能是虚函数**。因为虚函数是针对对象的，而构造函数是在对象产生之前运行
* **析构函数可以是虚函数**，而且通常声明为虚函数

##### 虚析构函数

问题背景：

在程序中用带指针参数的`delete`运算符撤销对象时，系统只会执行基类的析构函数，而不执行派生类的析构函数

解决方法：

将基类的析构函数声明为虚函数

* 析构函数设置为虚函数时，在使用指针引用时可以动态联编，实现运行时的多态，保证**使用基类类型的指针能够调用适当的析构函数**针对不同的对象进行清理工作
* 如果一个类的析构函数是虚函数，那么它**派生类的析构函数也是虚函数**，不管是否有`virtual`

##### 虚函数与重载函数的关系

虚函数是函数重载的另一种形式，但不同于一般的函数重载

* 普通的函数重载，其函数的**参数个数**或**参数类型**必须有所不同，返回类型也可以不同。如果仅仅返回类型不同，会**出错**
* 重载虚函数时，要求**函数名、返回类型、参数个数、参数类型和顺序**与基类虚函数原型完全相同。如果仅仅函数名相同，系统会视为**普通的函数重载**，这时会丢失虚函数的特性

#### 纯虚函数与抽象类

纯虚函数：

在基类中没有定义，要求在派生类中必须定义自己的版本，如果没有，则将继续被视为纯虚函数

纯虚函数声明形式：`virtual 函数类型 函数名(参数表)=0;`

抽象类：

如果一个类中至少有一个纯虚函数，这个类即为抽象类

* 不能建立抽象类的对象，抽象类只能作为其他类的基类来使用
* 抽象类**不能用作参数类型、函数返回类型或显式转换的类型**
* 可以声明指向抽象类的**指针**或**引用**，此指针可以**指向它的派生类**，进而实现多态性
* 抽象类的析构函数可以声明为纯虚函数
* 如果派生类中没有重新定义纯虚函数，那么这个派生类仍然是一个抽象类
* 抽象类中也可以定义**普通成员函数**，可以通过派生类对象来调用

#### 运算符重载

运算符重载实质上是将运算对象转化为**运算函数的实参**，并根据实参的类型来确定重载的运算函数

运算符重载的规则：

* 只能重载C++**已有的运算符**，不能臆造新的运算符
* 类属关系运算符`.`作用域分辨符`::`成员指针运算符`*`，`sizeof`运算符和三目运算符`?:`不能重载
* 重载之后运算符的**优先级和结合性都不能改变**，单目运算符只能为单目运算符，双目运算符只能为双目运算符
* 运算符重载后的功能应当与原功能相类似，且必须含义清楚，不能有二义性
* 重载时最好**成对重载**，例如定义了相等操作符，也应该定义不等操作符；定义了加，也应该定义减

运算符重载的一般格式为：

`类型 类名::operator 要重载的运算符(形参表)`

实际上`operator 重载运算符`即为重载的成员函数名，通过对象即可调用该成员函数

##### 单目和双目运算符重载

* 双目运算符

> 注意，赋值运算符使用this指针，**返回引用**

```c++
class Complex
{
private:
	float real, image;
public:
	Complex(float i = 0, float j = 0): real(i),image(j){}
	Complex operator+(const Complex &c);	//重载双目运算符+
	Complex& operator+=(const Complex &c);	//重载双目运算符+=
};
Complex  Complex::operator+(const Complex &c)
{
	Complex t;
	t.real = this->real + c.real;
	t.image = this->image + c.image;
	return t;
}
Complex&  Complex::operator+=(const Complex &c)
{
	this->real = this->real + c.real;
	this->image = this->image + c.image;
	return *this;
}
int main()
{
	Complex c1(1, 2), c2(2, 3), c3, c4;
	c3 = c1 + c2;	//相当于c3 = c1.operator+(c2);
	c4 += c2;		//相当于c4.operator+=(c2);
}
```

* 单目运算符（前置和后置）

> 后置运算符重载时，带有一个`int`形参，为了与前置运算符重载区分

```c++
class T
{
private:
	int a;
public:
    void get_a()
	{
		cout << this->a;
	}
	T(int i) :a(i) {}
	T& operator++();		//定义前置++重载
	T operator++(int);		//定义后置++重载
};
T& T::operator++()
{
	this->a++;		//加了之后再返回原来的值
	return *this;
}
T T::operator++(int)
{
	T t = *this;	//返回原来的值再加
	this->a++;
	return t;
}
int main()
{
	T t1(1), t2(1);
	(++t1).get_a();		//打印值为2，相当于(t1.operator++()).get_a();
	(t2++).get_a();		//打印值为1，相当于(t2.operator++(0)).get_a();	
}
```

##### 为什么函数要返回引用？

> * 允许连续赋值运算，例如想实现 c = c1 + c2 + c3，显然重载的+必须有返回实体（直接返回对象也可以）
> * 防止返回对象的时候调用拷贝构造函数和析构函数导致的**不必要的开销**，降低效率
> * 但如果返回对象是**局部变量**，则无法返回引用，`*this`或全局变量可以

##### 运算符重载为友元函数

当重载函数作为友元普通函数时，重载函数不能用对象调用，所以参加运算的对象必须以形参方式传送到重载函数内。

在二元运算符重载函数为友元函数时，形参通常为两个参加运算的对象

```c++
class Point
{
private:
	float x, y;
public:
	Point(int i = 0, int j = 0) :x(i), y(j) {}
	float get_x()
	{
		return x;
	}
	float get_y()
	{
		return y;
	}
	friend Point operator+(Point p1, Point p2);
	friend Point operator-(Point p1, Point p2);
};

Point operator+(Point p1, Point p2)
{
	return Point(p1.x + p2.x, p1.y + p2.y);
}
```

友元函数重载`++`运算符

```c++
class Time
{
private:
    int hour, minute, second;
public:
    Time(int h = 0, int m = 0, int s = 0);
    friend Time& operator++(Time &t);		//前置++
    friend Time operator++(Time &t, int);	//后置++
}
```

#### 类型重载

类型转换函数必须是**非静态**的**成员函数**，**不能定义为友元函数**，**无返回值**且**不带参数**

> 功能类似强制类型转换

```c++
class <类名1>
{
 public:
    operator <类型名2>( );
    //……
};
<类名1>::operator <类型名2>()
{     
    //函数体; 
}
```

举例如下：

```c++
class Time
{
private:
	int hour, minute, second;
public:
	Time(int h = 0, int m = 0, int s = 0) :hour(h), minute(m), second(s) {}
	operator float();		//Time类转换为float类型
};
Time::operator float()
{
	float sec;
	sec = hour * 3600 + minute * 60 + second;
	return sec;
}
int main()
{
	float s1, s2, s3;
	Time t(10, 15, 20);
	s1 = t;
	s2 = float(t);
	s3 = (float)t;
}
```

#### **重载总结**

* 注意运算符重载的规则和限制
* 重载运算符的时候要注意函数的**返回类型**（引用或对象）
* **前增量**和**后增量**运算符的重载区别
* 赋值运算符重载要注意**内存空间的释放**和**重新申请**
* 不可滥用