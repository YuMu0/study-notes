## 类与对象

#### 基础

* `private`处于类体第一部分时，关键字`private`可以忽略
* 类数据成员不可以是`auto`、`register`或`extern`

* 不能在类声明中给数据成员赋初始值

#### 内联函数和外联函数

内联函数：定义在类体外的成员函数，调用时直接用内联函数体的代码替换，节省调用开销，提高运行速度。与带参数的宏定义代码效率是一样的，但是要优于宏定义

外联函数：函数头前加关键字`inline`即可

> 函数声明为内联函数两种方式：隐式声明和`inline`显式声明

**注意：**

* 必须将函数体和`inline`结合在一起，否则编译器会将其视为普通函数
* 通常只有较短的成员函数才定义为内联函数

#### 对象的定义和使用

* 声明类的同时定义的对象是**全局对象**

* 声明一个类只是声明了一个类型，只有定义对象后，系统才分配存储空间

#### 构造函数

##### 构造函数

* 必须与类同名
* 可以不带参数
* 不返回任何值，也不需要指定为void类型
* 被声明为`共有函数`，但是不能被显式调用

利用构造函数创建对象有两种方法：

```c++
class Date
{
    //省略
};
Date date1(1999,4,18);
Date *date2 = new Date(1998,4,18);
```

##### 成员初始化表

对于`常量类型`和`引用类型`的数据成员，不能在构造函数中用赋值语句直接赋值

```c++
class A
{
    private:
    	int x;
    	int &rx;
    	const float pi;
    public:
    	A(int x1): x(x1), rx(x), pi(3.14){}
}
```

**注意：**

> 类成员是按照它们在类里被声明的顺序初始化的，与它们在初始化列表里列出的顺序无关

```c++
#include<iostream.h>
class D 
{
public:
	    D(int i):mem2(i),mem1(mem2+1)
        //声明时mem1在前，因此列表初始化时，mem1先初始化，而不是mem2先初始化
	    {
	        cout<<"mem1: "<<mem1<<endl;
	        cout<<"mem2: "<<mem2<<endl;
    	}
private:
	    int mem1;
	    int mem2;
};
int main()
{
	    D d(15);
}
//输出结果：
//mem1: -858993459
//mem2: 15
```

##### 缺省参数的构造函数

在声明构造函数时指定默认参数，而定义函数时可以不指定参数

##### 构造函数的重载

**说明：**

> * 建立对象时只执行一个构造函数
> * 无参的构造函数属于**默认构造函数**，一个类只能有一个默认构造函数

##### 拷贝构造函数

拷贝构造函数是一种特殊的构造函数，其形参是**对本对象的引用**

```c++
Coord(const Coord& p)
{
    //省略
}
```

**注意：**

> 每个类**必须有**一个拷贝构造函数，如果程序员没有定义，系统会自动生成一个缺省的拷贝构造函数

拷贝构造函数的调用有两种方法：

```c++
Coord p2(p1);  //代入法
Coord p3 = p1; //赋值法
```

调用拷贝构造函数有三种情况：

* 用类的一个对象去初始化另一个对象时
* 当函数的形参是类的对象，调用函数，进行形参和实参的结合时
* 当函数的返回值是对象，将函数返回值赋值给对象时

##### 浅拷贝和深拷贝

浅拷贝，即由缺省的拷贝构造函数所实现的数据成员逐一赋值，但若类中含有**指针类型数据**，则会产生错误

简单理解如下：

> 浅拷贝只拷贝指针地址，意思是浅拷贝指针都指向同一个内存空间，当原指针所指空间被释放时，浅拷贝的指针所指向的空间将全部失效
>
> 深拷贝是先申请一块与被拷贝数据同样大的内存空间，把数据复制过去。如此一来，双方将互不影响

#### 析构函数

析构函数的特点：

* 析构函数与构造函数名相同，但前面必须加一个波浪号(~)
* 析构函数**没有参数**，**没有返回值**，而且**不能重载**
* 当撤销对象时，编译系统会自动调用析构函数。如果程序员没有定义，系统将自动生成一个默认析构函数，但是其只能释放对象的数据成员所占空间，**不包括堆内存空间**

析构函数被调用的两种情况：

* 若一个对象被定义在一个函数体内，当这个函数结束时，析构函数被自动调用
* 若一个对象是使用`new`运算符动态创建，在使用`delete`释放时，自动调用析构函数

#### this指针

每一个类的成员函数都有一个隐藏定义的**常量指针**，即`this`指针。每当调用成员函数时，它被初始化为被调函数**所在类的对象的地址**。`*this`表示当前对象本身

#### 指向类成员的指针

**注意：**

> 指向成员的指针只能访问**公有**数据成员和成员函数，使用要先声明，再赋值，然后访问

##### 指向数据成员的指针

声明：`类型说明符 类名 :: * 数据成员指针名;`

赋值：`数据成员指针名 = &类名::数据成员名;`

使用：`对象名.*数据成员指针名;`或`对象指针名->*数据成员指针名;`

##### 指向成员函数的指针

声明：`类型说明符 (类名:: *指针名)(参数表);`

赋值：`成员函数指针名 = 类名::成员函数名;`

使用：`(对象名.*成员函数指针名)(参数表);`或`(对象指针名-> *成员函数指针名)(参数表);`

#### 向函数传递对象

##### 使用对象作为函数参数

与传递其他类型数据相同，**传值调用**，函数中对对象的任何修改不影响调用该函数的对象本身

##### 使用对象指针作为函数参数

与传递其他类型数据的指针相同，**传址调用**，可在被调用函数内改变参数对象的值。仅传入地址，而不进行副本的拷贝，可以提高运行效率，减少时空开销

##### 使用对象引用作为函数参数

不但具有用对象指针作函数参数的优点，而且用对象引用作函数参数将更简单、更直接

#### 静态成员

引入目的：实现一个类的不同对象之间**数据和函数共享**

##### 静态数据成员

* 用关键字`static`声明

* 该类的所有对象维护该成员的同一个拷贝，它是**类定义的一部分**，不因对象的建立而产生，也不因对象的析构而删除

* **必须在类外定义和初始化**，用`::`来指明所属的类，一般在类定义之后，`main()`之前进行
* 静态变量必须初始化，如果定义时不赋值，会被默认初始化为0

静态数据成员初始化格式如下：

`数据类型 类名::静态数据成员名 = 值;`

访问方式：

用类名访问：`类名::静态数据成员`

用对象访问：`对象名.静态数据对象`或`对象指针->静态数据成员`

**注意：**

> **私有静态数据成员**不能被类外部函数访问，也不能用对象或类进行访问。支持静态数据成员的一个主要原因是**可以不必使用全局变量**

使用场景举例：

```c++
class Student
{
    public
        Student()
        {
            count ++;	//每创建一个学生对象，学生数+1
            StudentNo = count;
        }
    private: 
    	static int count;	//统计学生总数
    	int StudentNo;		//表示学生学号
}
int Student::count = 0;
```

##### 静态成员函数

静态成员函数同样是类定义的一部分，它没有`this指针`，因而**无法访问非静态成员**，它的意义在于维护类的静态数据成员

静态成员函数可以访问的内容有：

* 类中的静态数据成员
* 类中的其他静态成员函数
* 程序的**全局变量**

调用方式：

用类名访问：`类名::静态成员函数名(参数表)`

用对象访问：`对象.静态成员函数名(参数表)`或`对象指针->静态成员函数名(参数表)`

**注意：**

* 静态成员函数可以定义成内嵌的，也可以定义在类外
* 使用静态成员函数的一个原因是，可以用它在建立对象之前处理类的静态数据，这是非静态成员函数无法做到的

#### 友元

友元可以访问与其有好友关系的类中的私有`private`成员，友元包括友元函数和友元类

##### 友元函数

友元函数是独立于当前类的外部函数，但它可以访问该类中的所有对象的成员，包括`private`、`protected`和`public`

友元函数提供了**不同类的成员函数之间**、**类的成员函数与一般函数之间**进行数据共享的机制

**注意：**

> 友元函数不是当前类的成员函数，其没有当前类的`this指针`，一般都通过将类作为函数参数来访问类的成员

```c++
class Time
{
    public:
    	Time(int, int, int);
    	frined void display(Time &);	//友元函数声明
    private:
    	int hour;
    	int minute;
    	int second;
};
Time::Time(int h, int m, int s)
{
    hour = h;
    minute = m;
    second = s;
}
void display(Time& t)	//友元函数定义
{
    cout << t.hour << ":" << t.minute << ":" << t.second << endl;
}
```

**注意：**

> 友元函数还可以是多个类的，在多个类中声明同一个友元函数，则该函数可以访问多个类的成员

友元函数也可以是另一个类的成员函数

```c++
class Date
{
	public:
    	friend void Time::display(Date &);	//将Time类的成员函数声明为Date类的友元函数
};
```

##### 友元类

将B类声明为A类的友元类时，友元类B中的所有成员函数都是A类的友元函数

```c++
class B
{
    //...
};
class A
{
    //...
    friend B;	//声明B为A的友元类
    //...
};
```

**注意：**

* 友元关系是**单向的**而非双向的
* 友元关系不能传递
* 友元类B中的成员函数要想访问A的成员，仍然要通过将类A设为函数参数的形式来进行

#### 对象成员

如果一个类的对象是另一个类的数据成员，则称这样的数据成员为对象成员

#### const的使用

`const`对象的一般形式：`const 类型名 对象名 = 初值`或 `类型名 const 对象名 = 初值`

**注意：**常对象必须要有初值

##### 常对象成员

常数据成员：值不能改变，只能在**声明时初始化**或者通过构**造函数参数初始化列表**进行初始化，不能通过在构造函数中赋值操作来初始化

```c++
class Time
{
    const int hour;
    //或const int hour = 0;
    Time(int h): hour(h){}
};
```

常成员函数：当函数声明中包含`const`时为常成员函数，此时函数只能引用本类中的数据成员，而不能修改

```c++
void showTime() const;
void showTime() const	//const是函数类型的一部分，因而实现时也要加上，但调用时不需要
{
    //...
}
```

**注意：**

> 若数据成员声明为`mutable`，则可以被修改

##### 指向常对象的指针

一般形式为：`const 类型 *指针变量名`

此时，指针指向的对象不能被改变，而指针变量本身可以改变

```c++
const char c = 'a';
const char *p = &c;
*p = 'b';	//错误
p++;		//正确
```

* 常对象只能用`const`型指针去指向它，而不能用非`const`型指针去指向
* `const`型指针除了可以指向常对象外，还可以指向非`const`型变量，但此时也不能通过指针修改变量值

```c++
const int a = 10, b = 20;	 //a,b都为const
int c = 30;
const int *pa = &a;		//正确
pa = &c;				//正确
int *pb = &b;			//错误
*pb = &c;				//正确
```

* 如果函数形参是非`const`型指针，则实参只能是非`const`型指针，不能用`const`型指针
* 如果函数参数是`const`型指针，则实参既可以是`const`型指针，也可以是非`const`型指针

```c++
void f1(Time *p);
void f2(const Time *p);
Time *p1;
const Time *p2;
f1(p1);	//正确
f1(p2);	//错误
f2(p1);	//正确
f2(p2);	//正确
```

注意：

```c++
const Time *p1;		//指向Time类常对象的指针，对象值不能改变
Time const *p2;		//指向Time类对象的常指针，指针值不能改变
const Time* const p3;	//指向Time类常对象的常指针，对象值和指针值都不能改变
```



##### 常对象

如果要求所有的数据成员的值都不允许被改变，则可以将对象声明为`const`

常对象只能调用它的常成员函数，**不能调用普通函数**

