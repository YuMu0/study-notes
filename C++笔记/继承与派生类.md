## 继承与派生类

#### 基础

* 继承的目的：代码重用和代码的扩充

* 继承方法程序设计思路：一般到特殊
* 基本概念：基类（父类）、派生类（子类）

* 继承种类：单继承、多继承
* 继承方式：`public/protected/private`
* 继承内容：除**构造函数、析构函数、私有成员**以外的其他成员

从已有类派生出心类时，可以在派生类内完成以下几种功能：

* 可以增加新的数据成员
* 可以增加新的成员函数
* 可以重新定义基类中已有的成员函数
* 可以改变现有成员的属性

基类与派生类的关系：

* 派生类是基类的具体化
* 派生类是基类定义的延续
* 派生类是基类的组合

声明一个派生类的一般格式：`class 派生类名: 继承方式 基类名 {};`

**注意：**

> 系统默认继承方式为私有继承`private`

#### 三种继承方式

不同继承方式的基类和派生类特征：

| 继承方式  |         基类特征         |          派生类特征          |
| :-------: | :----------------------: | :--------------------------: |
|  public   | public/protected/private |  public/protected/不可访问   |
|  private  | public/protected/private |   private/private/不可访问   |
| protected | public/protected/private | protected/protected/不可访问 |

不同继承方式的访问规则总结如下：

* 私有继承：通过派生类的对象不能访问基类中的任何成员
* 公有继承：通过派生类的对象只能访问基类的`public`成员
* 保护继承：通过派生类的对象不能访问基类中的任何成员

**注意：**

> 在公有派生的情况下，一个派生类的对象可以作为基类对象来使用的地方：
>
> * 派生类对象可以赋值给基类对象
> * 派生类对象可以初始化基类的引用
> * 派生类对象的地址可以赋值给指向基类的地址

但在后两种情况下，通过指针或引用只能访问派生类对象所继承的基类成员

```c++
class base 
{
	public: 
		void test1() 
		{
			cout << "test1:base" << endl; 
		}
};
class derived : public base
{
	public: 
		void test2() 
		{ 
			cout << "test2:derived" << endl; 
		}
};
void main()
{
	derived d; base &b = d;
	b.test2();	//错误
	b.test1();	//正确
}
```

`protected`成员的特点与作用：

* 在基类中，其与`private`成员的性质相同
* 在派生类中（私有继承和保护继承时），其与`public`成员的性质相同
* 既实现了数据隐藏，又方便继承，实现代码重用

#### 派生类的构造函数和析构函数

**执行顺序：**

创建派生类对象时，首先执行基类的构造函数，再执行派生类的构造函数；撤销派生类对象时，则**先执行派生类的析构函数，再执行基类的析构函数**

总之，析构函数执行顺序和构造函数执行**顺序相反**

**构造规则：**

当基类构造函数没有参数，或没有显式定义构造函数时，派生类可以不向基类传递参数，甚至可以不定义构造函数；

当基类**含有带参数的构造函数**时，派生类**必须定义构造函数**，以提供把参数传递给基类构造函数的的途径

如果派生类中还有内嵌对象，则将此对象构造函数后缀于派生类构造函数

```c++
class Base
{
    public:
    	Base(int n)		//基类的构造函数
        {
            i = n;
		}
    private:
    	int i;
};
class Derive: pulic Base
{
    public:
    	Derive(int n, int m): Base(m),d(m)	//派生类的构造函数，后面分别为基类构造函数和												  内嵌对象构造函数
        {
            j = n;
        }
    private:
    	int j;
    	Base d;
}
```

**注意：**

* 如果派生类的基类也是个派生类，每个类只负责其直接基类的构造即可
* 基类和派生类的析构函数是独立的，派生类中是否需要定义析构函数与基类无关

#### 多继承

一个派生类中具有多个基类时，这种派生方法称为**多基派生**或**多继承**

多继承声明方式如下：

```c++
class 派生类名: 继承方式1 基类名1,...,继承方式n 基类名n {};
```

注意：继承方式省略表示私有继承

```c++
class z: public x, y {};	//x为公有继承，y为私有继承
```

当多个基类中有同名成员时，使用类名限定可以消除二义性

```c++
Z obj;			//Z继承自X和Y
obj.X::fun();	//调用类X的fun()
obj.Y::fun();	//调用类Y的fun()
```

注意：

> 处于**同一层次**各基类构造函数执行顺序，取决于**声明派生类时所指定各基类的顺序**，与派生类构造函数中所定义的成员初始化列表的各项顺序无关

#### 虚基类

当出现**菱形继承**时（B和C继承自A，D继承自B和C），派生类D中就拥有了多个A中成员的拷贝，有两种方式进行分辨：

* 使用**作用域标识符**进行唯一表示
* 定义**A为虚基类**，**B和C虚继承**自A，使得派生类D中只保留一份拷贝

虚继承定义方式：

`class 派生类名: virtual 继承方式 基类名{};`

或`class 派生类名: 继承方式 virtual 基类名{};`

虚基类的初始化：

虚基类的成员由**最远派生类D**的构造函数通过调用虚基类A的构造函数进行初始化，派生类D的其他基类B和C对虚基类的构造函数的调用都被自动忽略

> 如此便保证了虚基类的成员只被初始化一次

```c++
class Base
{
public:
	int a;
	Base(int i): a(i){}		//虚基类Base的构造函数
};

class Derive1: virtual public Base
{
public:
	Derive1(int i): Base(i){}	//Derive1的构造函数
};

class Derive2 : virtual public Base
{
public:
	Derive2(int i): Base(i){}	//Derive2的构造函数
};

class Derive : public Derive1, public Derive2
{
public:
    //实际上只有Base(i+j)会被调用，但是Derive1(i)和Derive2(j)不可省略
	Derive(int i, int j): Base(i+j), Derive1(i), Derive2(j){}	//Derive的构造函数
};

int main()
{
	Derive D(1, 2);
	cout << D.a;		//输出结果为3
}
```

构造函数执行顺序：

* 同一层次中，先调用**虚基类**的构造函数，再调用**非虚基类**的构造函数，最后调用**派生类**构造函数
* 对于多个虚基类或者多个非虚基类，同一层次构造函数执行顺序在**继承位置顺序**（**不是构造函数初始化列表顺序**）先左后右，不同层次自上而下

#### 赋值兼容规则

即需要**基类对象**的任何地方都可以使用**公有派生类**的对象替代，如此一来，公有派生类实际上就具备了基类的所有特性，凡基类能解决的问题，派生类都能解决。

**注意：**

* **只能使用从基类继承来的成员**。例如将派生类对象的地址赋值给基类的指针，或者使用派生类对象来初始化基类的引用时，通过指针或引用的操作只能访问或修改从基类继承来的成员
* 只能用公有派生类替代，其他继承方式不可以

