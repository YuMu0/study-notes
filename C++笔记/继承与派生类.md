## 继承与派生类

#### 基础

* 继承的目的：代码重用和代码的扩充

* 继承方法程序设计思路：一般到特殊
* 基本概念：基类（父类）、派生类（子类）

* 继承种类：单继承、多继承
* 继承方式：`public/protected/private`
* 继承内容：除**构造函数、析构函数、私有成员**以外的其他成员

从已有类派生出心类时，可以在派生类内完成以下几种功能：

* 可以增加新的数据成员
* 可以增加新的成员函数
* 可以重新定义基类中已有的成员函数
* 可以改变现有成员的属性

基类与派生类的关系：

* 派生类是基类的具体化
* 派生类是基类定义的延续
* 派生类是基类的组合

声明一个派生类的一般格式：`class 派生类名: 继承方式 基类名 {};`

**注意：**

> 系统默认继承方式为私有继承`private`

#### 三种继承方式

不同继承方式的基类和派生类特征：

| 继承方式  |         基类特征         |          派生类特征          |
| :-------: | :----------------------: | :--------------------------: |
|  public   | public/protected/private |  public/protected/不可访问   |
|  private  | public/protected/private |   private/private/不可访问   |
| protected | public/protected/private | protected/protected/不可访问 |

不同继承方式的访问规则总结如下：

* 私有继承：通过派生类的对象不能访问基类中的任何成员
* 公有继承：通过派生类的对象只能访问基类的`public`成员
* 保护继承：通过派生类的对象不能访问基类中的任何成员

**注意：**

> 在公有派生的情况下，一个派生类的对象可以作为基类对象来使用的地方：
>
> * 派生类对象可以赋值给基类对象
> * 派生类对象可以初始化基类的引用
> * 派生类对象的地址可以赋值给指向基类的地址

但在后两种情况下，通过指针或引用只能访问派生类对象所继承的基类成员

```c++
class base 
{
	public: 
		void test1() 
		{
			cout << "test1:base" << endl; 
		}
};
class derived : public base
{
	public: 
		void test2() 
		{ 
			cout << "test2:derived" << endl; 
		}
};
void main()
{
	derived d; base &b = d;
	b.test2();	//错误
	b.test1();	//正确
}
```

`protected`成员的特点与作用：

* 在基类中，其与`private`成员的性质相同
* 在派生类中（私有继承和保护继承时），其与`public`成员的性质相同
* 既实现了数据隐藏，又方便继承，实现代码重用

#### 派生类的构造函数和析构函数

**执行顺序：**

创建派生类对象时，首先执行基类的构造函数，再执行派生类的构造函数；撤销派生类对象时，则**先执行派生类的析构函数，再执行基类的析构函数**

总之，析构函数执行顺序和构造函数执行**顺序相反**

**构造规则：**

当基类构造函数没有参数，或没有显式定义构造函数时，派生类可以不向基类传递参数，甚至可以不定义构造函数；

当基类**含有带参数的构造函数**时，派生类**必须定义构造函数**，以提供把参数传递给基类构造函数的的途径

如果派生类中还有内嵌对象，则将此对象构造函数后缀于派生类构造函数

```c++
class Base
{
    public:
    	Base(int n)		//基类的构造函数
        {
            i = n;
		}
    private:
    	int i;
};
class Derive: pulic Base
{
    public:
    	Derive(int n, int m): Base(m),d(m)	//派生类的构造函数，后面分别为基类构造函数和												  内嵌对象构造函数
        {
            j = n;
        }
    private:
    	int j;
    	Base d;
}
```

**注意：**

* 如果派生类的基类也是个派生类，每个类只负责其直接基类的构造即可
* 基类和派生类的析构函数是独立的，派生类中是否需要定义析构函数与基类无关

#### 多继承

一个派生类中具有多个基类时，这种派生方法称为**多基派生**或**多继承**

多继承声明方式如下：

```c++
class 派生类名: 继承方式1 基类名1,...,继承方式n 基类名n {};
```

注意：继承方式省略表示私有继承

```c++
class z: public x, y {};	//x为公有继承，y为私有继承
```

当多个基类中有同名成员时，使用类名限定可以消除二义性

```c++
Z obj;			//Z继承自X和Y
obj.X::fun();	//调用类X的fun()
obj.Y::fun();	//调用类Y的fun()
```

注意：

> 处于**同一层次**各基类构造函数执行顺序，取决于**声明派生类时所指定各基类的顺序**，与派生类构造函数中所定义的成员初始化列表的各项顺序无关

#### 虚基类