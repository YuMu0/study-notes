#### C++多态

1. 静态多态

即重载和模板，静态多态在**编译期间**完成，编译器会根据实参类型来调用合适的函数

2. 动态多态

程序在**运行时**根据基类的指针指向的对象来确定自己该调用哪个类的虚函数

#### 虚函数

不能被定义为虚函数的函数：

* 友元函数，它不是类的成员函数
* 静态成员函数，它属于类，不属于某个对象
* 构造函数，构造函数执行时，还没有对象生成，无法执行动态绑定
* 内联函数，因为内联函数不能在运行中动态确定其位置

#### 引用和指针有什么区别？

* 定义一个指针变量时，编译器会为它分配内存，而引用不占用任何内存
* 引用必须在定义时被初始化，指针不必
* 不存在指向空值的引用，但存在指向空值的指针

#### new/delete和malloc/free的区别

* new/new[]：完成了两件事，先底层调用malloc分配了内存，然后调用构造函数创建对象
* delete/delete[]：也完成了两件事，先调用析构函数清理资源，然后底层调用free释放空间
* new在申请时会自动计算所需字节数，而malloc则需要我们输入申请内存空间的字节数

#### this指针

* this指针是一个const指针，不能在程序中修改它或给它赋值
* this指针是一个局部数据，它的作用域仅在一个对象的内部



**成员delete this合法吗？**

合法，但

* 必须保证this对象是通过`new`分配的
* 必须保证调用`delete this`的成员函数是最后一个调用this的成员函数
* 必须保证`delete this`后没有人使用了

#### 智能指针

C++标准库中，头文件：`#include<memory>`

**C++11**

1. shared_ptr
2. unique_ptr
3. weak_ptr
4. auto_ptr（被C++11弃用）

* Class shared_ptr实现**共享式拥有**(shared ownership)概念。多个智能指针指向相同的对象，该对象和其资源会在“最后一个reference被销毁时被释放。为了在结构较复杂的场景中工作，标准库提供weak_ptr、bad_weak_ptr和enable_shared_from_this等辅助类
* Class unique_ptr实现**独占式拥有**(exclusive ownership)或**严格拥有**(strict ownership)概念，保证同一时间内只有一个智能指针可以指向该对象，你可以移交所有权。它对于**避免内存泄露**(resource leak)——如new后忘记delete——特别有用

**shared_ptr**

多个智能指针可以共享同一个对象，对象的最末一个拥有者有责任销毁对象，并清理与该对象相关的所有资源

* 支持**定制型删除器**(custom deleter)

**weak_ptr**

weak_ptr允许你共享但不拥有某对象，一旦最末一个拥有该对象的shared_ptr智能指针失去了所有权，任何weak_ptr都会自动成空。因此，在default和copy构造函数外，weak_ptr只提供“**接受一个shared_ptr**"的构造函数。它是对对象的一种弱引用，不会增加对象的引用计数

* 可打**破环状引用**的问题（两个其实已经没有被使用的对象彼此互指，使之看似还在"被使用"的状态）

shared_ptr循环引用举例：

```c++
class A
{
    shared_ptr<B> pb;
    ~A();
}
class B
{
    shared_ptr<A> pa;
    ~B();
}
int main()
{
    shared_ptr<A> objA(new A());
    shared_ptr<B> objB(new B());
    
    objA->pb = objB;	//A和B内部互相引用
    objB->pa = objA;
    
    return 0；
}
```

解决方式：

```c++
class A
{
    weak_ptr<B> pb;		//shared_ptr改为weak_ptr就解决了互相引用的问题
    ~A();
}
class B
{
    weak_ptr<A> pa;
    ~B();
}
int main()
{
    shared_ptr<A> objA(new A());
    shared_ptr<B> objB(new B());
    
    objA->pb = objB;	//A和B内部互相引用
    objB->pa = objA;
    
    return 0；
}
```

**unique_ptr**

unique_ptr是C++11才开始提供的类型，是一种在异常时可以帮助避免资源泄露的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源在同一时间只被一个pointer拥有。一旦拥有者被销毁或定义empty，或开始指向另一个对象，先前拥有的那个对象就会被销毁，其相应资源同时被释放

* unique_ptr用于**取代auto_ptr**

**注意：**

> 智能指针的拷贝是浅拷贝，如果我们直接改变了对象的值，那么指向它的指针都会指向新值

#### 智能指针shared_ptr的实现

```c++
/*智能指针类定义*/
template<class T>
class SmartPtr
{
private:
	T *ptr;
	int *use_count;		//引用计数必须用指针实现，这样才能都维护一份计数
public:
	SmartPtr(T *p);
	~SmartPtr();
	SmartPtr(const SmartPtr<T> &orig);
	SmartPtr<T> & operator = (const SmartPtr<T> &orig);
};

/*构造函数*/
template<class T>
SmartPtr<T>::SmartPtr(T *p) : ptr(p)
{
	try 
	{
		use_count = new int(1);
	}
	catch (...)
	{
		delete ptr;
		ptr = nullptr;
		use_count = nullptr;
		cout << "Allocate memory for use_count fails" << endl;
		exit(1);
	}
	cout << "Constructor is called!" << endl;
}

/*析构函数*/
template<class T>
SmartPtr<T>::~SmartPtr()
{
	/*只有最后一个引用时才释放内存*/
	if (--(*use_count) == 0)
	{
		delete ptr;
		ptr = nullptr;
		delete use_count;
		use_count = nullptr;
		cout << "Destructor is called!" << endl;
	}
}

/*拷贝构造函数*/
template<class T>
SmartPtr<T>::SmartPtr(const SmartPtr<T>& orig)
{
	ptr = orig.ptr;
	use_count = orig.use_count;
	(*use_count)++;
	cout << "Copy constructor is called!" << endl;
}

/*赋值操作符重载*/
template<class T>
SmartPtr<T>& SmartPtr<T>::operator = (const SmartPtr<T> &orig)
{
    ++(*orig.use_count);		//先让原先的引用计数+1

	/*=左边的指针对象引用数-1，如果为0，要释放*/
    if (--(*this->use_count) == 0)
    {
        delete ptr;
        delete use_count;
        cout << "Left side object is deleted!" << endl;
    }

    this->ptr = orig.ptr;
    this->use_count = orig.use_count;
    
    cout << "Assignment operator overloaded is called!" << endl;
    return *this;
}
```

#### 强制类型转换运算符

旧式风格的类型转换

```
type(expr); // 函数形式的强制类型转换
(type)expr; // C语言风格的强制类型转换
```

现代C++风格的类型转换

```
cast-name<type>(expression)
```

**static_cast**

任何编写程序时能够明确的类型转换**都可以使用**static_cast（不能转换掉底层const、volatile和_unaligned属性）。其**不提供运行时的检查**，所以叫static_cast，因此需要在编写程序时**确认转换的安全性**

主要在以下几个场合中使用：

* 用于类层次结构中，父类和子类之间指针和引用的转换
  * 上行转换，把子类对象的指针/引用转换为父类的指针/引用，这种转换是安全的
  * 下行转换，把父类对象的指针/引用转换为子类的指针/引用，这种转换是不安全的，需要编写程序时进行确认

* 用于**基本数据类型之间**的转换，如int转char，int转enum等，需要编程时确认安全性，不能用于基本数据类型指针之间的转换
* 把void指针转换成目标类型的指针（极其不安全）

> 上行转换是一种隐式转换

注意：**C++基本类型的指针之间不含有隐式类型转换**

```c++
base* b;
child* c;
c = static_cast<child*> b;	//正确
c = b;		//编译错误
```

**dynamic_cast**

会在运行时检查类型转换是否合法，具有一定安全性，但是会额外消耗一些性能

使用场景与static相似。在类层次结构中使用时，上行转换与static_cast没有区别，都是安全的；下行转换时，会检查转换的类型，比static_cast更安全

* 仅适用于**类指针或类引用**，不能用于基本数据类型的指针或引用

**const_cast**

用于移除类型的const、volatile和_unaligned属性，常量指针/引用被转换成非常量指针/引用，并仍然指向原来的对象

**reinterpret_cast**

非常激进的指针类型转换，在编译期完成，可以**转换任何类型的指针**，所以**极不安全**，非极端情况不要使用

#### AVL树/红黑树/B树/B+树

**AVL树**

最早的平衡二叉树之一，应用相对其他数据结构较少，windows对进程地址空间的管理用到了AVL树

其规定节点左右子树的高度差必须小于等于1

**红黑树**

红黑树相比于AVL树，**牺牲了部分的平衡性**，以换取删除、插入操作时**少量的旋转次数**，因此**插入效率更高**。但是由于牺牲了部分树的平衡性，**查找效率稍低**

平衡二叉树，广泛用在C++的STL中，如map和set都是用红黑树实现的

**B树**

N叉平衡树，每个节点可以有更多的子节点，新的值可以插在已有节点上，而不需要改变树的高度，从而大量减少重新平衡和数据迁移的次数

用在磁盘文件组织、数据索引和数据库索引

为什么它们不用二叉树？

因为要考虑磁盘IO的影响，它相对于内存来说是很慢的。数据库索引是存储在磁盘上的，当数据量很大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（即对应每索引的每一个节点）。所以我们要减少IO次数，对于树来说，就是树的高度

**B+树**

B+树与B树的不同：

* 非叶节点全是索引，所有数据都在子节点会重复出现，也就是说查询必定要到叶节点
* 叶节点本身按照关键字的大小自小而大顺序连接

![6](D:\文件\markdown笔记\C++笔记\C++常见面试题.assets\20170717205509476.png)

B+树相比于B树的优势：

* 叶节点形成一个有序链表，更方便查找
* 所有的查询都要查找到叶节点，查询性能是稳定的
* 如果是进行范围查询，B树必须要通过中序遍历查找每个元素，而B+树只需要找到最小的元素再从链表依次遍历即可



**Trie树（字典树）**

并不是平衡树，也不一定非要有序。主要用于前缀匹配，用在统计和排序大量字符串

#### static关键字

1. （面向对象的）静态成员变量

* 其属于类，而不属于某个对象，所有对象共享此变量
* 其**必须在类的外部初始化**
* 其内存空间既不是在声明类时分配，也不是在创建对象时分配，而是在类外初始化时分配（也就是说，没有在类外初始化的static成员变量不能使用）
* static成员变量**不占用对象的内存**，而是在对象之外开辟内存，与普通的static成员变量类似，都在内存分区的全局区分配内存

2. （面向对象的）静态成员函数

* 属于类本身，而不属于某对象，因而**不具有this指针**
* 没有this指针，不知道指向哪个对象，因此**一般只访问static静态成员**
* 如果非要访问非静态数据成员，必须通过**参数传递的方式得到对象名**
* 类外代码可以使用类名和作用域操作符来调用公有静态成员函数

3. （面向过程的）静态全局变量

该变量在全局数据区分配内存，自动变量会随着函数的退出而释放空间，而全局数据区的数据不会因为函数的退出而释放内存；静态全局变量不能被其他文件所用，可以防止命名冲突

4. （面向过程的）静态局部变量

在全局数据区内分配内存。程序执行到声明处被首次初始化，之后再次调用函数时，不会再初始化；不能被其他文件所用，可以防止命名冲突

5. （面向过程的）静态函数

不能被其他文件所用，可以防止命名冲突

#### const关键字

总的来说：

1. 用于变量修饰，表示这个变量不能被修改

2. 用于指针修饰，表明指针的指向物不能被修改

3. 用于方法修饰，表明这个方法不会对对象造成改变

在类中使用时：

1. const成员变量

* 初始化const成员变量只有一种方法，就是通过**构造函数的初始列表**

2. const成员函数`T fun() const;`

* 可以使用类中的所有成员变量，但**不能修改他们的值**
* 声明和定义都要加**const**，`T fun()`和`T fun() const`是两种不同的函数原型

**const成员函数**

1. const成员函数可以访问**非const对象的所有数据成员**，也可以访问**const对象内的所有数据成员**
2. 非const成员函数可以访问**非const对象的所有数据成员**，但**不可以**访问**const对象的任意数据成员**

3. 如果只有const成员函数，非const成员是可以调用的。当const版本和非const版本的成员函数同时出现时，非const对象调用非const成员函数
4. const对象只能调用const成员函数，必须提供一个const版本的成员函数

> 要想在const函数中修改成员变量，或者想要修改const对象的成员变量，则将这个变量用`mutable`修饰即可

const与#define的区别：

`#define`属于宏，是预处理器的一部分。预处理是在编译之前的一道程序，简单地用字符串进行替换

#### struct和class的区别

* C++对C语言的的struct做了扩展，让其拥有了很多class的特性，两者几乎可以划等号
* 细节方面的不同，class默认`private`权限，而struct默认`public`权限

使用时，最好遵守：

> 仅当只有数据时使用struct，其它一概使用class

#### protected关键字

保护成员的可访问范围比私有成员大，比公有成员小，能访问私有成员的地方都能访问保护成员

保护成员扩大的访问范围表现在，**基类的保护成员可以在派生类的成员函数中被访问**

引入保护成员的理由，或者说保护成员的使用场景如下：

* 出于隐藏目的不宜设为公有
* 但又确实需要在派生类的成员函数中经常访问的基类成员，

将它们设为保护成员，既能起到隐藏目的，又避免了派生类成员函数要访问它们时只能间接访问所带来的麻烦

#### 继承

注意默认继承方式是私有继承

```c++
Class z：public x,y 	//公有继承x，私有继承y
```



#### STL相关

##### vector

vector内部是用**动态数组**的方式实现的，当进行`insert()`或`push_back()`增加元素时，如果动态数组的内存不够用，就要动态的重新分配当前大小的1.5~2倍（**指数增加**）的新内存区，再把原数组的内容复制进去。所以，在一般情况下，其访问速度与一般数组相比，只有在重新分配时，性能才会下降

* 进行`pop_back()`时，`capacity`并不会变小
* 如果进行大量的`push_back()`，应当使用`reserve()`函数**提前设定其大小**，否则会出现很多次容量扩充操作，导致效率低下

`size()`返回容器中有多少元素，`capacity()`返回容器当前的总空间大小

`resize()`既修改capacity大小，也修改size大小；`reserve()`只修改capacity大小，不修改size大小

##### emplace_back()和push_back()的区别

在引入右值引用、转移构造函数、转移复制运算符之前，通常使用`push_back()`向容器中加入一个右值元素（临时变量）。这时候首先会调用构造函数构造这个临时变量，然后需要调用拷贝构造函数将这个临时变量对象放入容器中，最后原来的临时变量释放掉，这样造成的问题就是临时变量申请资源的浪费



#### 栈与堆的区别

1. 分配和管理方式不同

堆是动态分配的，其空间的分配和释放都由程序员控制；栈由编译器自动管理

2. 产生碎片不同

对堆来说，频繁的new/delete或者malloc/free可能会造成内存空间的不连续，造成大量的碎片，使程序效率低下；对栈而言，则不存在碎片问题，因为栈是先进后出的队列，永远不可能有一个内存块从栈中间弹出

3. 增长方向不同

堆由低地址向高地址增长；栈由高地址向低地址增长

#### 面向对象的三大特性

**封装**

对外只暴露最小完整可用接口，隐藏内部实现细节。封装解决了数据的安全性，体现了对象为自己负责

**继承**

继承最大的意义其实是为了实现多态。继承会带来高耦合，增加代码维护的难度，因此**少用继承多用组合**

**多态**

给多态下一个定义：

> 同一个操作，作用于不同的对象，会产生不同的结果

#### 设计模式

设计模式的核心就两个词：**组合**与**解耦**

[C++设计模式详解博客](https://www.cnblogs.com/chengjundu/p/8473564.html)

**1. 工厂模式**

在工厂模式中，创建对象时不会对客户端暴露创建逻辑，而是通过使用一个共同的接口来指向新创建的对象。工厂模式作为一种创建模式，一般在创建复杂对象时，考虑使用；在创建简单对象时，建议直接通过`new`来完成



**2. 单例模式**

简单来说就是一个类只能构建一个对象的设计模式

其关键实现在于

* 构造函数是**私有的**，即禁止用户自己声明并定义实例
* 禁止赋值和拷贝`=delete`
* 类里有个获取实例的静态函数，可以全局访问

优点

* 单例模式会阻止其他对象实例化自己单例对象的副本，从而确保所有对象都访问唯一的实体

使用场景，例如在Windows下就只能打开一个任务管理器。如果不使用机制对窗口对象进行唯一化，将弹出多个窗口，如果这些窗口显示的内容完全一致，则是重复对象，浪费内存资源；如果不同窗口内容不一致，更会给用户带来误解

单例模式分为懒汉模式和饿汉模式

**2.1 懒汉模式**

即第一次用到类实例的时候才会去实例化一个对象。在访问量很小，甚至可能不会去访问的情况下，采用懒汉实现，这是以时间换空间。懒汉模式需要考虑线程安全

懒汉式一般实现：非线程安全

```c++
//懒汉式一般实现：非线程安全，getInstance返回的实例指针需要delete
class Singleton
{
public:
    static Singleton* getInstance();
    ~Singleton(){}
private:
    Singleton(){}                                        //构造函数私有
    Singleton(const Singleton& obj) = delete;            //明确拒绝
    Singleton& operator=(const Singleton& obj) = delete; //明确拒绝
    
    static Singleton* m_pSingleton;
};

Singleton* Singleton::m_pSingleton = NULL;

Singleton* Singleton::getInstance()
{
    if(m_pSingleton == NULL)
    {
        m_pSingleton = new Singleton;
    }
    return m_pSingleton;
}
```

要想线程安全，要么考虑加锁，要么返回一个reference指向local static对象，这种实现方式的好处是不需要去delete它

```c++
class Singleton
{
public:
    static Singleton& getInstance();
private:
    Singleton(){}
    Singleton(const Singleton&) = delete;  //明确拒绝
    Singleton& operator=(const Singleton&) = delete; //明确拒绝
};

Singleton& Singleton::getInstance()
{
    static Singleton singleton;
    return singleton;
}
```

**2.2 饿汉模式**

即单例类定义的时候就进行实例化。在访问量比较大，或者可能访问的线程比较多的时候，采用饿汉实现，可以实现更好的性能，这是以空间换时间

```c++
//饿汉式：线程安全，注意一定要在合适的地方去delete它
class Singleton
{
public:
    static Singleton* getInstance();
private:
    Singleton(){}                                    //构造函数私有
    Singleton(const Singleton&) = delete;            //明确拒绝
    Singleton& operator=(const Singleton&) = delete; //明确拒绝

    static Singleton* m_pSingleton;
};

Singleton* Singleton::m_pSingleton = new Singleton();

Singleton* Singleton::getInstance()
{
    return m_pSingleton;
}
```



#### C++构造函数列表初始化

必须使用列表初始化的情形有：

* 类中的**常量类型**和**引用类型**
* 子类初始化父类的私有成员
* 显式调用父类构造函数

注意，变量赋值的顺序是根据类中声明的顺序，而不是初始化列表的顺序

#### 解决哈希冲突的办法

虽然我们不希望发生冲突，但实际上发生冲突的可能性是存在的。当关键字值域

1. 开放定址法

key对应的当前位置已经有值或不是我们想查找的值时，就往后找空余的位置填上

2. 拉链法

即在冲突的节点后面接一个单链表，把冲突的值都放在这

#### 哈希函数的构造方法

构造哈希函数的原则有

* 函数本身方便计算
* 计算出来的地址分布均匀，目的是尽可能减少冲突

构造方法：

1. 数字分析法

如果事先知道关键字集合，并且每个关键字的位数比哈希表的码位数多，可以从关键字中选出分布较为均匀的若干位，构成哈希地址

2. 平方取中法

可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。这是因为，平方后中间几位和关键字中每一位都相关，故不同关键字会以比较高的概率产生不同的哈希地址

3. 分段叠加法

按照哈希表地址位数将关键字分成位数相等的几部分，然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址

4. 除留余数法

对关键字进行取模运算得到哈希值

#### C++类的空间计算

空的类是会占用内存空间的，而且大小是1，原因是C++要求每个实例在内存中都有独一无二的地址

1. 类内部的成员变量

* 普通的变量：占用内存，注意字节对齐原则（和struct类型相似）
* static修饰的静态变量：不占用内存，原因是编译器将其放在全局区

2. 类内部的成员函数

* 普通函数：不占用内存
* 虚函数：有一个指向虚函数表的指针（32位系统为4字节，64位系统为8字节）。所以一个类的虚函数所占用的空间是不变的，和虚函数个数无关

3. 存在类继承的情况

* 总体上空间为父类加上子类新定义的部分
* 继承后只有一个虚表指针

#### struct空间计算

总体有两个原则

* 整体空间是占用空间最大的成员类型所占字节数的整数倍。但若最大成员类型所占字节数超过4，如double是8，则整体空间是4的倍数即可
* **数据对齐原则**——内存按照结构体成员定义的先后顺序排列，当排到该成员变量时，其前面摆放的空间大小必须是该成员类型大小的整数倍，如果不够则补齐（这些空间不放任何东西），依次向后推

为什么要字节对齐？

计算机并非逐字节大小读写内存，而是以2、4、8的倍数的字节块来读写内存，如此以来就会对基本数据类型的合法地址做出一些限制，即它的地址必须是2、4、8的倍数。那么就要求各种数据类型按照一定的规则在空间上排列，这就是对齐

字节对齐看似浪费了很多内存空间，但最重要的意义是为了**调高内存系统读写的效率**

#### 虚函数和虚函数表

C++编译器保证虚表指针存在于对象实例中**最前面的位置**。这是为了保证取到虚函数表有着最高的性能——如果有多重继承或多层继承的情况下。这意味着我们可以通过对象实例的地址获得这张虚函数表，然后就可以遍历其中的函数指针，并调用相应的函数

* 虚函数表属于类，类的所有对象共享这个类的虚函数表
* 不同对象虚函数表是一样的（虚函数表的第一个地址相同）
* 每个对象内部都保存一个虚表指针`vptr`，每个对象的虚表指针存放地址都不同，但都指向同一个虚函数表

#### 函数形参

函数形参为什么使用const引用？

使用&引用传递，可以防止值传递时复制数据，使用const是为了保证数据不被改动。因此const&是为了防止传值时拷贝构造函数的调用开销

另外，当形参为const引用时，实参可以传入常量，有可以传入变量；但若形参为非const引用，只能传入变量