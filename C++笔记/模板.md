## 模板

一个程序的功能在对**不同的数据类型**进行**相同处理过程**时，可以将所处理的**数据类型说明为参数**，于是就产生了模板的概念

#### 函数模板

函数模板实例化为**模板函数**，模板函数和**重载**是密切相关的

函数模板声明方式：

```c++
template <class/typename 类型参数>
返回类型 函数名（模板形参表）
{
	函数体
}
```

* 类型参数可以有多个

```c++
template <class type1, class type2>
void fun(type1 x, type2 y)
{
    //...
}
```

* 函数也可以使用模板参数表中未给出，但是已存在的数据类型的参数

```c++
template <class T>
T fun(T arg1, int arg2)
{
    //...
}
```

函数模板调用方式：

```c++
函数名（实参表）;
```

* 实例化T的各模板之间必须保持完全的一致，函数模板中没有隐式的类型转换

```c++
template <class T>
void fun(T x, T y)
{
    //...
}
void f(int i, char c)
{
    fun(i, i);	//正确
    fun(c, c);	//正确
    fun(i, c);	//错误，类型不匹配
    fun(i, int(c));		//正确
}
```

模板函数重载的调用顺序：

* 先寻找一个**参数完全匹配的函数**，如果找到就调用它
* 再寻找一个**函数模板**，将其实例化，产生一个匹配的模板函数，若找到就调用它
* 再试试低一级的对函数的重载方法，例如通过**类型转换**寻找参数匹配

#### 类模板

类模板的定义方式：

```c++
template <class/typename T>
class ClassName
{
    //...
}
```

类模板实例化方式：

```c++
ClassName<T> ObjName
```

编译时，编译器先根据`<T>`的内容实例化类模板，生成模板类，然后使用该模板类声明模板类对象