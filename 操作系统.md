## 操作系统

#### 进程和线程的区别

* 进程是具有一定功能的**程序**关于某个数据集合上的**一次运行活动**，它是系统进行资源调度和分配的一个独立单位
* 线程是进程的实体，是**CPU调度和分派的基本单位**，它是比进程更小的能独立运行的基本单位
* 一个进程有多个线程，多个线程也可以并发执行

**注意：**本质上，线程的内存空间是天然共享的。线程间同步是为了防止竞争（例如因同时修改而导致的数据不一致）；而进程的内存空间是天然独立的，因此需要进程通信

[关于线程和进程的解释--阮一峰](http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html) *留言处有更多精彩评论*

#### 线程同步的方式

* **互斥量**：通过**互斥锁Mutex**（Mutual exclusion)实现。采用互斥对象限制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问
* **信号量Semaphore**：它允许同一个时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
* 事件（信号）：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较

[线程同步的几种方式](https://www.cnblogs.com/lebronjames/archive/2010/08/11/1797702.html)

#### 进程的通信方式

主要分为：管道、系统IPC（包括消息队列、信号量、共享存储）、套接字SOCKET

管道又主要分为：普通管道PIPE、流管道（s_pipe)、命名管道(name_pipe)

* 管道是一种半双工的通信方式，数据只能单向流动，并且只能在具有亲缘关系的进程间流动，进程的亲缘关系通常是父子进程
* 命名管道也是半双工的通信方式，它允许无亲缘关系的进程间进行通信
* 信号量是一个计数器，用来控制多个进程对资源的访问，它通常作为一种锁机制
* 消息队列是消息的链表，存放在内核中并由消息队列标识符标识
* 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生
* 共享内存就是映射一段能被其它进程访问的内存，这段共享内存由一个进程创建，但是多个进程可以访问

[进程间的几种通信方式](https://blog.csdn.net/yufaw/article/details/7409596)

#### 缓冲区溢出

缓冲溢出是指计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上

危害主要有：

* 程序崩溃，导致拒绝服务
* 跳转并执行一段恶意代码

缓冲区溢出的主要原因是程序中没有仔细检查用户输入

#### 死锁

在两个或多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗讲就是两个或多个进程**无限期的阻塞**、**相互等待**的一种状态

死锁产生的四个条件（有一个不成立，则不会产生死锁）

* 互斥条件：一个资源一次只能被一个进程使用
* 请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放
* 不剥夺条件：进程获得的资源，在未完全使用完之前，不能被强行剥夺
* 循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系

解决死锁的级别方法：

**预防死锁：**

* 资源的一次性分配：（破坏请求和保持条件）
* 可剥夺资源：当某个进程新的资源未满足时，释放已占用资源（破坏不可剥夺条件）
* 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏循环等待条件）

**避免死锁：**

预防死锁的几种策略会**严重损害系统性能**

在避免死锁的策略中，允许进程**动态地申请资源**。因而，系统在进行资源分配之前预**先计算资源分配的安全性**。若此次分配不会导致系统进入不安全状态，则将资源分配给进程，反之则进程等待

**检测死锁：**

首先为每个进程和每个资源指定一个唯一的号码，然后建立**资源分配表**和**进程等待表**

**解除死锁：**

当发现有进程死锁后，便立即将它从死锁状态中解脱出来，常用方法有：

* 剥夺资源：从其他进程中剥夺足够数量的资源给死锁进程，以解除死锁状态
* 撤销进程：直接撤销死锁进程或其他撤销代价更小的进程

#### 进程的状态

* 就绪状态：进程已获得除处理机以外的所需资源，等待处理机资源
* 运行状态：占用处理机资源运行，处于此状态的进程数**小于等于CPU数**
* 阻塞状态：进程等待某种条件，在条件满足之前无法执行

进程三种状态之间的常见转换：

![img](D:\文件\markdown笔记\操作系统.assets\v2-3f4aadb10de757a548e60e3d86caf7aa_b.jpg)

* 就绪→运行：处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便由就绪状态转变为运行状态
* 运行→就绪：运行过程中，因分配给它的一个时间片已经用完而不得不让出处理机，于是进程的状态转变为就绪
* 运行→阻塞：运行过程中，因等待某种事件的发生而无法进行执行，便转变为阻塞状态。例如等待键盘输入
* 阻塞→就绪：若等待的事件已经完成，便转变为就绪状态

