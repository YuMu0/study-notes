## 操作系统

#### 进程和线程的区别

* 进程是具有一定功能的**程序**关于某个数据集合上的**一次运行活动**，它是系统进行资源调度和分配的一个独立单位
* 线程是进程的实体，是**CPU调度和分派的基本单位**，它是比进程更小的能独立运行的基本单位
* 一个进程有多个线程，多个线程也可以并发执行

**注意：**本质上，线程的内存空间是天然共享的。线程间同步是为了防止竞争（例如因同时修改而导致的数据不一致）；而进程的内存空间是天然独立的，因此需要进程通信

[关于线程和进程的解释--阮一峰](http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html) *留言处有更多精彩评论*

#### 线程同步的方式

* **互斥量**：通过**互斥锁Mutex**（Mutual exclusion)实现。采用互斥对象限制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问
* **信号量Semaphore**：它允许同一个时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
* 事件（信号）：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较

[线程同步的几种方式](https://www.cnblogs.com/lebronjames/archive/2010/08/11/1797702.html)

#### 进程的通信方式

进程间通信(Inter Process Communication, IPC)

主要分为：管道、消息队列、信号量、共享存储、套接字SOCKET，前四种主要用于同一台机器上的进程间通信，而套接字主要用于不同机器之间的网络通信

1. 管道

* 管道是一种半双工的通信方式，数据只能单向流动。如果要进行双工通信，则需要建立两个管道
* 管道只能用于父子进程或兄弟进程间通信，也就是说管道只能用于具有亲缘关系的进程间通信

2. 命名管道FIFO

* FIFO也是半双工的通信方式，它可以在无关的进程之间交换数据，与无名管道不同
* 它以一种特殊设备文件形式存在于文件系统中

3. 消息队列

* 消息队列是一个在系统内核中用来保存消息的队列，它在系统内核中是以消息链表的形式出现
* 消息队列跟有名管道有不少相同之处，进行通信的进程可以是不相关的进程，

* 消息队列独立于发送与接收过程。进程终止时，消息队列及其内容不会被删除

4. 信号量

* 它与其他几种IPC方式不同，信号量是一个计数器，用户实现进程间的互斥与同步，通知接收进程某个事件已经发生，而不是存储进程间通信数据

5. 共享内存

* 共享内存是最快的一种IPC，因为进程是直接对内存进行存取
* 但是共享内存的同步问题自身无法解决，即进程何时该去共享内存取得数据，而何时不能取。因此常与信号量结合使用

[进程间的几种通信方式](https://blog.csdn.net/yufaw/article/details/7409596)

#### 缓冲区溢出

缓冲溢出是指计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上

危害主要有：

* 程序崩溃，导致拒绝服务
* 跳转并执行一段恶意代码

缓冲区溢出的主要原因是程序中没有仔细检查用户输入

#### 死锁

在两个或多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗讲就是两个或多个进程**无限期的阻塞**、**相互等待**的一种状态

死锁产生的四个条件（有一个不成立，则不会产生死锁）

* 互斥条件：一个资源一次只能被一个进程使用
* 请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放
* 不剥夺条件：进程获得的资源，在未完全使用完之前，不能被强行剥夺
* 循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系

解决死锁的级别方法：

**预防死锁：**

* 资源的一次性分配：（破坏请求和保持条件）
* 可剥夺资源：当某个进程新的资源未满足时，释放已占用资源（破坏不可剥夺条件）
* 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏循环等待条件）

**避免死锁：**

预防死锁的几种策略会**严重损害系统性能**

在避免死锁的策略中，允许进程**动态地申请资源**。因而，系统在进行资源分配之前预**先计算资源分配的安全性**。若此次分配不会导致系统进入不安全状态，则将资源分配给进程，反之则进程等待

**检测死锁：**

首先为每个进程和每个资源指定一个唯一的号码，然后建立**资源分配表**和**进程等待表**

**解除死锁：**

当发现有进程死锁后，便立即将它从死锁状态中解脱出来，常用方法有：

* 剥夺资源：从其他进程中剥夺足够数量的资源给死锁进程，以解除死锁状态
* 撤销进程：直接撤销死锁进程或其他撤销代价更小的进程

#### 进程的状态

* 就绪状态：进程已获得除处理机以外的所需资源，等待处理机资源
* 运行状态：占用处理机资源运行，处于此状态的进程数**小于等于CPU数**
* 阻塞状态：进程等待某种条件，在条件满足之前无法执行

进程三种状态之间的常见转换：

![img](D:\文件\markdown笔记\操作系统.assets\v2-3f4aadb10de757a548e60e3d86caf7aa_b.jpg)

* 就绪→运行：处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便由就绪状态转变为运行状态
* 运行→就绪：运行过程中，因分配给它的一个时间片已经用完而不得不让出处理机，于是进程的状态转变为就绪
* 运行→阻塞：运行过程中，因等待某种事件的发生而无法进行执行，便转变为阻塞状态。例如等待键盘输入
* 阻塞→就绪：若等待的事件已经完成，便转变为就绪状态

#### C语言内存分区

C语言开发对内存使用有区域划分，分别是**栈区(stack)**、**堆区(heap)**、**bss段(bss)**、**数据段(data)**和**代码段(text)**

![img](D:\文件\markdown笔记\操作系统.assets\v2-deb39dc05a514a6e3bcf5751be932846_b.jpg)

* 栈区：函数中定义变量存放的区域，例如常见的`int/float/char`等变量，以及指针变量，`const`**常量也位于栈区**。它的特点是由系统自动分配和释放，不需要程序员考虑资源回收的问题，方便简洁。注意：栈区的地址分配是从内存的高地址开始向低地址分配，是**连续的**
* 堆区：通过指令自主向系统申请的区域，大小由自己决定，在使用完之后需要自己通过指令去释放该区域内测，否则可能出现内测浪费与溢出，C语言中即`malloc/free`。堆中的内存空间**不是连续的**

* bss(Block Started by Symbol)段：通常是存放程序中**未初始化**的全局变量和`static`静态变量的一块内存区域，bss段属于静态内存分配。若未初始化，系统会自动将其值设置为0。在C++中，无论是否初始化，都存放在这
* 数据段：C语言全局变量和静态变量初始化之后，存放在这

* 代码段：代码段通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于**只读**

#### 用户态和内核态

##### 用户态与内核态的区别

用户态和内核态是操作系统的**两种运行级别**

当一个任务（进程）执行系统调用而陷入内核代码中执行时，就称进程处于内核运行态，简称内核态，其他的属于用户态。用户程序运行在用户态，操作系统运行在内核态

用户态不能干扰内核态，所以CPU指令就有两种，**特权指令**和**非特权指令**，不同的状态对应不同的指令。特权指令只能由操作系统内核部分调用，不允许用户直接使用

所以，内核态执行全部指令，而用户态执行非特权指令

##### 为什么要区分用户态和内核态

是为了保护操作系统。因为操作系统中的一些重要数据，是不允许修改和破坏的

##### 用户态切换到内核态的方式

1. 系统调用

这是用户态进程**主动要求切换**到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。这也是操作系统提供给应用程序使用内核功能的接口，是用户取得操作系统服务的唯一途径

2. 异常

当CPU在执行用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常

3. 外围设备的中断

当外围设备完成用户请求的操作时，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条将要执行的指令，转而去执行与中断信号对应的处理程序。如果先前执行的指令是用户态下的程序，那么这个转换自然就发生了由用户态到内核态的切换。比如硬盘读写操作完成